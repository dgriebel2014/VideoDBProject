<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <meta charset="UTF-8" />
    <title>VideoDB Demo</title>
    <style>
        /* Basic reset and font */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: sans-serif;
            background-color: #f6f6f6;
            color: #333;
            padding: 16px;
        }

        /* Container for the three horizontal panels */
        .container {
            display: flex;
            flex-direction: row;
            gap: 16px;
            height: 80vh; /* Adjust as needed */
        }

        /* Left panel (List of tasks) */
        .panel-left {
            flex: 0 0 25%;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            overflow-y: auto;
        }

            .panel-left h2 {
                margin-bottom: 0.5em;
                font-size: 1.2em;
                color: #2c3e50;
            }

        .task-list {
            list-style-type: none;
            padding-left: 0;
        }

            .task-list li {
                margin-bottom: 16px;
            }

            .task-list a {
                color: #0066cc;
                text-decoration: none;
                font-weight: bold;
                cursor: pointer;
            }

        .task-description {
            display: block;
            margin-top: 4px;
            font-size: 0.85em;
            color: #555;
        }

        /* Middle panel (Console) */
        .panel-middle {
            flex: 0 0 35%;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            overflow-y: auto;
        }

            .panel-middle h2 {
                margin-bottom: 0.5em;
                font-size: 1.2em;
                color: #2c3e50;
            }

        .console-log {
            background: #fafafa;
            border: 1px solid #ddd;
            min-height: 60vh;
            padding: 8px;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 0.9em;
        }

        /* Right panel (Code Snippets) */
        .panel-right {
            flex: 1;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            overflow-y: auto;
        }

            .panel-right h2 {
                margin-bottom: 0.5em;
                font-size: 1.2em;
                color: #2c3e50;
            }

        .code-pane {
            border: 1px solid #ddd;
            background: #fefefe;
            min-height: 60vh;
            border-radius: 4px;
            padding: 8px;
            font-family: monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h3>VideoDB Demo Page</h3>
    <br />
    <p>
        The <code>VideoDB</code> class is a GPU-backed alternative to <code>IndexedDB</code>, designed for high-performance data storage and retrieval. It leverages <code>WebGPU</code> to manage data in GPU memory, allowing for faster access and computation compared to traditional browser storage solutions.
        The class supports various data types, including JSON objects and typed arrays (e.g., Float32Array, Float64Array, Int32Array, Uint32Array, Uint8Array), making it suitable for applications requiring efficient handling of structured or binary data.
    </p>
    <br />
    <p>
        <button onclick="downloadFile()">Click here to download VideoDB.ts</button>
        <script>
            async function downloadFile() {
                const response = await fetch("https://raw.githubusercontent.com/dgriebel2014/VideoDBProject/master/src/VideoDB.ts");
                const fileContent = await response.text();

                const blob = new Blob([fileContent], { type: 'text/plain' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = "VideoDB.ts";
                link.click();

                URL.revokeObjectURL(link.href);
            }
        </script>
        <br /><br />
        <b>Copyright © 2025 Jon Griebel - dgriebel2014@gmail.com. All rights reserved.  Distributed under the MIT license.</b>&nbsp;
        <br />
        <i style="font-size:small">Chat GPT o1ProMode by OpenAI assisted with the development of the code, documentation and the demo page for this class.</i>
    </p>
    <br />
    <p>
        Select a link in the first panel to view console logs (middle panel) and the corresponding code snippets (right panel).
    </p>
    <br />

    <div class="container">
        <!-- Left Panel: List of tasks/links -->
        <div class="panel-left">
            <h2>VideoDB Tasks</h2>
            <ul class="task-list">
                <!-- Keep GPU check -->
                <li>
                    <a href="#" data-task="checkGPU">Check GPU Availability</a>
                    <span class="task-description">Quickly verify if WebGPU is supported in the user’s browser.</span>
                </li>

                <!-- Single, combined test for all store types -->
                <li>
                    <a href="#" data-task="manageAllStores">Create and Manage All Store Types</a>
                    <span class="task-description">Create, put data, get data, delete data, then delete the store for JSON, Float32, Float64, Int32, Uint32, Uint8.</span>
                </li>

                <!-- Insert this block below the existing "Create and Manage All Store Types" list item -->
                <li>
                    <a href="#" data-task="testErrors">Force a Bunch of Errors</a>
                    <span class="task-description">Deliberately attempt invalid operations to showcase error handling.</span>
                </li>

                <li>
                    <a href="#" data-task="stressTest">Stress Test (Performance / Benchmark)</a>
                    <span class="task-description">Run a multi-phase performance test on various store types (JSON, Float32, Float64, Int32, Uint8).</span>
                </li>

                <li>
                    <a href="#" data-task="accuracyTest">Accuracy Test / GET Benchmark</a>
                    <span class="task-description">
                        Creates an object store, stores data, then confirms data accuracy and measures GET performance.
                    </span>
                </li>

                <li>
                    <a href="#" data-task="classDocs">Class Documentation</a>
                    <span class="task-description">View the complete VideoDB class docs in the right pane.</span>
                </li>
            </ul>
        </div>

        <!-- Middle Panel: Console Output -->
        <div class="panel-middle">
            <h2>Console View</h2>
            <div class="console-log" id="consoleLog">
                <!-- Textual messages from tasks appear here. -->
            </div>
        </div>

        <!-- Right Panel: Code Snippets -->
        <div class="panel-right">
            <h2>Code Snippets</h2>
            <div id="codePane">
                <!-- Code or commands for the chosen task will appear here. -->
                <p>No code to show. Select a task from the left panel.</p>
            </div>
        </div>
    </div>

    <!-- Updated script block -->
    <script type="module">
        import { VideoDB } from './js/VideoDB.js';

        /**
         * Logs a message to the consoleLog div (middle panel).
         * - Converts `[SUCCESS]` to green text.
         * - Converts `[ERROR]` to red text.
         * - Inserts line breaks for newlines.
         * @param {string} msg - The message to display in the console area.
         * @returns {void}
         */
        function logToConsole(msg) {
            const consoleDiv = document.getElementById('consoleLog');

            // Replace [SUCCESS] / [ERROR] / [TASK] tags with colored <b> elements
            // Also convert any "\n" (newlines) into <br/> for line breaks in HTML
            let styledMsg = msg
                .replace(/\[SUCCESS\]/g, "<b style='color: green;'>[SUCCESS]</b>")
                .replace(/\[ERROR\]/g, "<b style='color: red;'>[ERROR]</b>")
                .replace(/\[TASK\]/g, "<b style='color: navy;'>[TASK]</b>")
                .replace(/\[RESULTS\]/g, "<b style='color: navy;'>[RESULTS]</b>")
                .replace(/\[STEP\]/g, "<b>[STEP]</b>")
                .replace(/\n/g, "<br/>");

            // Append the formatted message (plus a new line) to the existing HTML
            consoleDiv.innerHTML += styledMsg + "<br/>";
        }

        /**
         * Logs an HTML-based command to the codePane div (right panel), with formatting.
         * @param {string} htmlCommand - The HTML content to display in the code area as a command.
         * @returns {void}
         */
        function logCommandToConsole(htmlCommand) {
            const codeDiv = document.getElementById('codePane');
            // Append to existing content, preserving any existing code
            codeDiv.innerHTML += `<div style="margin-left: 10px;"><strong>${htmlCommand}</strong></div>`;
        }

        /**
         * Clears the console window (middle panel).
         * @returns {void}
         */
        function clearConsole() {
            const consoleDiv = document.getElementById('consoleLog');
            consoleDiv.textContent = '';
        }

        /**
         * Clears the code pane (right panel).
         * @returns {void}
         */
        function clearCodePane() {
            const codeDiv = document.getElementById('codePane');
            codeDiv.innerHTML = '<p></p>';
        }

        // We'll keep a reference to our VideoDB instance and device
        let videoDB = null;
        let device = null;

        /**
         * Initializes the page by attaching event listeners for each task link.
         * @returns {Promise<void>}
         */
        async function initDemoPage() {
            // Attach event listeners for each link with a data-task attribute
            const taskLinks = document.querySelectorAll('.task-list a[data-task]');
            taskLinks.forEach(link => {
                link.addEventListener('click', async (event) => {
                    event.preventDefault();
                    const task = link.getAttribute('data-task');

                    // Clear both console and code pane before each new task
                    clearConsole();
                    clearCodePane();

                    switch (task) {
                        case 'checkGPU':
                            await checkGPU();
                            break;
                        case 'manageAllStores':
                            await manageAllStores();
                            break;
                        case 'testErrors':
                            await testErrors();
                            break;
                        case 'stressTest':
                            await stressTest();
                            break;
                        case 'classDocs':
                            showClassDocs();
                            break;
                        case 'accuracyTest':
                            await accuracyTest();
                            break;
                        default:
                            logToConsole(`[ERROR] Unknown task: ${task}`);
                            break;
                    }
                });
            });
        }

        /**
         * Sets up the GPU device and creates a VideoDB instance for use in demos.
         * @returns {Promise<void>}
         */
        async function setupDevice() {
            if (!('gpu' in navigator)) {
                logToConsole("[INFO] WebGPU is not supported in this environment.");
                logToConsole("If using Chrome or Edge, try enabling WebGPU in chrome://flags or edge://flags.");
                return;
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                logToConsole("[ERROR] Failed to get GPU adapter.");
                logToConsole("Check if experimental features are enabled (chrome://flags or edge://flags).");
                return;
            }
            if (device) {
                device = undefined;
            }
            device = await adapter.requestDevice();
            if (videoDB) {
                videoDB = undefined;
            }
            videoDB = new VideoDB(device);

            // Just to confirm that we have the device
            logToConsole("[INFO] Successfully created VideoDB instance.");
        }

        /**
         * Quickly verify if WebGPU is supported in the user’s browser.
         * @returns {Promise<void>}
         */
        async function checkGPU() {
            logToConsole("[TASK] Checking GPU availability...");

            // STEP 1: Attempt to create or confirm the GPU device
            logToConsole("[STEP] Attempting to request the GPU device...");
            if (!device) {
                await setupDevice();
            }

            // STEP 2: Success or fail message
            if (device) {
                logToConsole("[SUCCESS] GPU device is available. WebGPU is supported.");
                logToConsole("If you had issues, ensure your Chrome/Edge flags are set to enable WebGPU.");
            } else {
                logToConsole("[FAIL] WebGPU not supported or device not available.");
                logToConsole("Enable WebGPU via chrome://flags or edge://flags, then relaunch.");
            }

            // Show code snippet in the right pane
            logCommandToConsole(`
<code>
<b style='color:green;'>// 1. Attempt to request the GPU device</b><br />
const adapter = await navigator.gpu.requestAdapter();<br />
if (!adapter) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;logToConsole("[ERROR] Failed to get GPU adapter.");<br />
&nbsp;&nbsp;&nbsp;&nbsp;return;<br />
}<br /><br />

<b style='color:green;'>// 2. Create the device and instantiate VideoDB</b><br />
device = await adapter.requestDevice();<br />
videoDB = new VideoDB(device);<br /><br />
</code>
                `);
        }

        /**
         * A helper to perform a multi-step test (create → add → get → put → openCursor → delete row → clear → delete store)
         * for any store configuration (JSON or typed arrays).
         * @param {string} storeName
         * @param {object} storeOptions - Options for createObjectStore
         * @param {*} dataToInsert - Data to insert (JSON object or TypedArray)
         * @param {string} key - The key under which data will be inserted
         */
        async function manageSingleStore(storeName, storeOptions, dataToInsert, key) {
            logToConsole(`[TASK] Managing store '${storeName}'...`);

            // [STEP] Create the store
            logToConsole(`[STEP] Creating store '${storeName}'...`);
            videoDB.createObjectStore(storeName, storeOptions);
            logToConsole(`[SUCCESS] Created '${storeName}'.`);

            logCommandToConsole(
                `<code>
<b style='color:green;'>// [STEP] Create the store: ${storeName}</b><br />
videoDB.createObjectStore("${storeName}", ${JSON.stringify(storeOptions, null, 4)});<br /><br />
</code>`
            );

            // [STEP] Add data (fails if the key already exists)
            let snippetForDataToInsert;
            if (storeOptions.dataType === "TypedArray") {
                // Example: new Float32Array([1.11, 2.22, 3.33])
                const arrayData = Array.from(dataToInsert);
                snippetForDataToInsert = `new ${storeOptions.typedArrayType}(${JSON.stringify(arrayData)})`;
            } else {
                // JSON or other data gets normal JSON.stringify
                snippetForDataToInsert = JSON.stringify(dataToInsert, null, 4);
            }

            logToConsole(`[STEP] Adding data into '${storeName}' under key '${key}': ${JSON.stringify(dataToInsert)}`);
            await videoDB.add(storeName, key, dataToInsert);
            logToConsole(`[SUCCESS] Data added under key '${key}'.`);

            logCommandToConsole(
                `<code>
<b style='color:green;'>// [STEP] Add data (will fail if key exists)</b><br />
const dataToAdd = ${snippetForDataToInsert};<br />
await videoDB.add("${storeName}", "${key}", dataToAdd);<br /><br />
</code>`
            );

            // [STEP] Get the data to confirm the 'add' worked
            logToConsole(`[STEP] Retrieving data from '${storeName}' key '${key}'...`);
            let retrieved = await videoDB.get(storeName, key);

            let retrievedStr = retrieved;
            // Convert typed array to string if necessary
            if (retrieved && typeof retrieved.join === "function") {
                retrievedStr = retrieved.join(", ");
            } else if (typeof retrieved === "object") {
                retrievedStr = JSON.stringify(retrieved);
            }
            logToConsole(`[SUCCESS] Retrieved (from add): ${retrievedStr}`);

            logCommandToConsole(
                `<code>
<b style='color:green;'>// [STEP] Get data</b><br />
const retrievedAdd = await videoDB.get("${storeName}", "${key}");
console.log("Retrieved after add:", retrievedAdd);<br /><br />
</code>`
            );

            // [STEP] Put data (same key) to demonstrate an update/overwrite
            const updateObj = (storeOptions.dataType === "TypedArray")
                ? new self[storeOptions.typedArrayType]([9, 8, 7]) // just an example array
                : { updatedField: "newValue", time: Date.now() };

            logToConsole(`[STEP] Putting updated data into '${storeName}' under key '${key}'...`);
            await videoDB.put(storeName, key, updateObj);
            logToConsole(`[SUCCESS] Data updated (overwritten) under key '${key}'.`);

            let snippetForUpdate;
            if (storeOptions.dataType === "TypedArray") {
                snippetForUpdate = `new ${storeOptions.typedArrayType}([9, 8, 7])`;
            } else {
                snippetForUpdate = JSON.stringify(updateObj, null, 4);
            }

            logCommandToConsole(
                `<code>
<b style='color:green;'>// [STEP] Put data (overwrite existing key)</b><br />
const updatedData = ${snippetForUpdate};<br />
await videoDB.put("${storeName}", "${key}", updatedData);<br /><br />
</code>`
            );

            // [STEP] OpenCursor to show all active records in the store
            logToConsole(`[STEP] Iterating over store entries with openCursor...`);
            logCommandToConsole(
                `<code>
<b style='color:green;'>// [STEP] OpenCursor to view all keys/values</b><br />
for await (const record of videoDB.openCursor("${storeName}")) {
    console.log(record.key, record.value);
}<br /><br />
</code>`
            );
            try {
                for await (const record of videoDB.openCursor(storeName)) {
                    logToConsole(`Cursor found key='${record.key}' => ${JSON.stringify(record.value)}`);
                }
            } catch (err) {
                logToConsole(`[ERROR] ${err.message}`);
            }
            logToConsole(`[SUCCESS] openCursor() iteration finished for '${storeName}'.`);

            // [STEP] Delete the single record
            logToConsole(`[STEP] Deleting the single record from the store...`);
            await videoDB.delete(storeName, key);
            logToConsole(`[SUCCESS] The record with key '${key}' was deleted.`);

            logCommandToConsole(
                `<code>
<b style='color:green;'>// [STEP] Delete a single record by key</b><br />
await videoDB.delete("${storeName}", "${key}");<br /><br />
</code>`
            );

            // [STEP] Clear the entire store
            logToConsole(`[STEP] Clearing all data in the store...`);
            await videoDB.clear(storeName);
            logToConsole(`[SUCCESS] The store '${storeName}' has been cleared.`);

            logCommandToConsole(
                `<code>
<b style='color:green;'>// [STEP] Clear the store</b><br />
videoDB.clear("${storeName}");<br /><br />
</code>`
            );

            // [STEP] Finally, delete the store
            logToConsole(`[STEP] Deleting store '${storeName}'...`);
            videoDB.deleteObjectStore(storeName);
            logToConsole(`[SUCCESS] '${storeName}' deleted.`);

            logCommandToConsole(
                `<code>
<b style='color:green;'>// [STEP] Delete the store</b><br />
videoDB.deleteObjectStore("${storeName}");<br /><br />
</code>`
            );

            // End with a blank line for spacing in the console
            logToConsole("");
        }

        /**
         * Combined multi-step test: creates and manages
         * (1) JSON store, (2) Float32Array, (3) Float64Array,
         * (4) Int32Array, (5) Uint32Array, (6) Uint8Array.
         */
        async function manageAllStores() {
            // Ensure we have a device/videoDB
            if (!device || !videoDB) {
                await setupDevice();
            }

            try {
                // 1) JSON store
                await manageSingleStore(
                    "jsonStore",
                    {
                        dataType: "JSON",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    { greeting: "Hello JSON Store!", time: Date.now() },
                    "myJsonKey"
                );

                // 2) Float32Array
                await manageSingleStore(
                    "float32Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Float32Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Float32Array([1.11, 2.22, 3.33]),
                    "myFloat32Key"
                );

                // 3) Float64Array
                await manageSingleStore(
                    "float64Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Float64Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Float64Array([10.01, 20.02, 30.03]),
                    "myFloat64Key"
                );

                // 4) Int32Array
                await manageSingleStore(
                    "int32Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Int32Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Int32Array([-1, 0, 99999]),
                    "myInt32Key"
                );

                // 5) Uint32Array
                await manageSingleStore(
                    "uint32Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Uint32Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Uint32Array([123456, 987654321, 42]),
                    "myUint32Key"
                );

                // 6) Uint8Array
                await manageSingleStore(
                    "uint8Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Uint8Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Uint8Array([0, 255, 128, 64]),
                    "myUint8Key"
                );

                logToConsole("[SUCCESS] All store types created, managed, and deleted in one go!");
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
        }

        /**
         * Demonstrates an Accuracy Test / GET Benchmark:
         * 1) Creates N object stores (e.g., 10 or 50).
         * 2) Fills each store with many thousands of records (if desired), storing the expected data in memory.
         * 3) Confirms data accuracy by sampling only a fraction of rows (accuracySampleSize).
         * 4) Benchmarks GET performance for:
         *    (A) SEQUENTIAL single-record GETs
         *    (B) RANDOM single-record GETs
         *    (C) BATCHED GETs across all stores
         */
        async function accuracyTest() {
            clearConsole();
            clearCodePane();

            logToConsole("[TASK] Accuracy Test / GET Benchmark\n");

            // Ensure we have a GPU device
            if (!device || !videoDB) {
                await setupDevice();
            }

            // Customize these values for large tests
            const storeCount = 1;          // e.g., create 10 or 50 stores
            const recordsPerStore = 10000; // e.g., 10,000 rows per store
            const bufferSizeMB = 50;       // GPU buffer size in MB (for each store's buffer)
            const accuracySampleSize = 1000; // Number of rows to check for correctness (random sample)
            const batchedGetPercent = 15;  // Percentage of rows to read in each store during batched GET

            // We'll keep an in-memory map of all data so we can confirm accuracy (at least for sampled rows)
            const inMemoryData = [];

            logToConsole(`[STEP] Creating ${storeCount} store(s), each with ${recordsPerStore} records...`);

            try {
                // Create multiple stores
                for (let s = 1; s <= storeCount; s++) {
                    const storeName = `accuracyStore_${s}`;

                    // Alternate between JSON and TypedArray for variety
                    const isJson = (s % 2 === 0); // even stores => JSON, odd => TypedArray
                    const storeOptions = isJson
                        ? {
                            dataType: "JSON",
                            bufferSize: bufferSizeMB * 1024 * 1024,
                            totalRows: recordsPerStore
                        }
                        : {
                            dataType: "TypedArray",
                            typedArrayType: "Float32Array",
                            bufferSize: bufferSizeMB * 1024 * 1024,
                            totalRows: recordsPerStore
                        };

                    videoDB.createObjectStore(storeName, storeOptions);

                    // Insert records
                    for (let r = 0; r < recordsPerStore; r++) {
                        const key = `rec_${r}`;
                        let value;

                        if (isJson) {
                            // ~1KB JSON object
                            value = createJsonObject1KB();
                        } else {
                            // ~1KB Float32Array (about 256 floats)
                            const floatCount = 256;
                            value = new Float32Array(floatCount);
                            for (let i = 0; i < floatCount; i++) {
                                value[i] = Math.random() * 1000;
                            }
                        }

                        // Save the expected data (for potential accuracy checks)
                        // We store *every* row’s info in memory, but we'll only check a subset.
                        inMemoryData.push({ storeName, key, expected: value });

                        // Use "put" to allow multiple test runs (avoids "duplicate key" issues)
                        await videoDB.put(storeName, key, value);
                    }
                }

                logToConsole("[SUCCESS] All stores created and populated.");

                // Accuracy Check for a subset of rows
                const totalRecords = inMemoryData.length;
                logToConsole(`[STEP] Verifying accuracy on ${accuracySampleSize} random rows (out of ${totalRecords})...`);

                // Build a random sample of indexes
                const sampledIndexes = randomSampleArrayIndexes(totalRecords, accuracySampleSize);

                let mismatches = 0;
                for (let i = 0; i < sampledIndexes.length; i++) {
                    const idx = sampledIndexes[i];
                    const { storeName, key, expected } = inMemoryData[idx];
                    const actual = await videoDB.get(storeName, key);

                    if (!compareValues(expected, actual)) {
                        mismatches++;
                        if (mismatches < 10) {
                            logToConsole(`[ERROR] Mismatch in store='${storeName}', key='${key}'.`);
                        }
                    }
                }

                if (mismatches === 0) {
                    logToConsole("[SUCCESS] All sampled records match exactly! Accuracy confirmed.\n");
                } else {
                    logToConsole(`[ERROR] Found ${mismatches} mismatches in sampled data retrieval! Check logs above.\n`);
                }

                // ===========================
                // 5) GET PERFORMANCE MEASUREMENT
                // ===========================

                // (A) SEQUENTIAL GET
                logToConsole("[STEP] Starting SEQUENTIAL GET performance test (3 seconds)...");
                const seqRate = await measureGetRate(inMemoryData, 3000, /*randomAccess=*/false);
                logToConsole(`[RESULTS] SEQUENTIAL GET: ~${seqRate.toLocaleString()} GETs/sec\n`);

                // (B) RANDOM GET
                logToConsole("[STEP] Starting RANDOM GET performance test (3 seconds)...");
                const randRate = await measureGetRate(inMemoryData, 3000, /*randomAccess=*/true);
                logToConsole(`[RESULTS] RANDOM GET: ~${randRate.toLocaleString()} GETs/sec\n`);

                // (C1) NON-CONTIGUOUS BATCHED GET (shuffled)
                logToConsole("[STEP] Starting NON-CONTIGUOUS BATCHED GET performance test (3 seconds)...");
                const batchRateNonContiguous = await measureNonContiguousBatchedGetRate(inMemoryData, 3000, batchedGetPercent);
                logToConsole(`[RESULTS] NON-CONTIGUOUS BATCHED GET: ~${batchRateNonContiguous.toLocaleString()} GETs/sec\n`);

                // (C2) CONTIGUOUS BATCHED GET (in insertion order)
                logToConsole("[STEP] Starting CONTIGUOUS BATCHED GET performance test (3 seconds)...");
                const batchRateContiguous = await measureContiguousBatchedGetRate(inMemoryData, 3000, batchedGetPercent);
                logToConsole(`[RESULTS] CONTIGUOUS BATCHED GET: ~${batchRateContiguous.toLocaleString()} GETs/sec\n`);

                logToConsole("[INFO] Accuracy Test / GET Benchmark Completed.");
            } catch (err) {
                logToConsole(`[ERROR] ${err.message}`);
            }

            // ---------------------------------
            // Helper: Compare two values (Float32Array or JSON) for accuracy
            // ---------------------------------
            function compareValues(expected, actual) {
                if (expected instanceof Float32Array && actual instanceof Float32Array) {
                    if (expected.length !== actual.length) return false;
                    for (let i = 0; i < expected.length; i++) {
                        if (expected[i] !== actual[i]) return false;
                    }
                    return true;
                } else if (typeof expected === "object" && typeof actual === "object") {
                    return JSON.stringify(expected) === JSON.stringify(actual);
                } else {
                    return expected === actual;
                }
            }

            /**
             * Returns an array of random unique indexes from [0..(max-1)], up to max if sampleSize > max
             */
            function randomSampleArrayIndexes(max, sampleSize) {
                const result = [];
                const taken = new Set();

                // If sampleSize is larger than max, just sample everything
                const finalSize = Math.min(sampleSize, max);

                while (result.length < finalSize) {
                    const randomIndex = Math.floor(Math.random() * max);
                    if (!taken.has(randomIndex)) {
                        taken.add(randomIndex);
                        result.push(randomIndex);
                    }
                }
                return result;
            }
        }

        /**
         * Measures single-record GET operations per second for a specified duration.
         * Optionally randomizes the access pattern.
         *
         * @param {Array<{storeName: string, key: string, expected: any}>} dataMap - The array of stored records.
         * @param {number} durationMs - How long to run the GET benchmark.
         * @param {boolean} randomAccess - If true, randomize read order; otherwise sequential.
         * @returns {Promise<number>} Approximate GET ops per second.
         */
        async function measureGetRate(dataMap, durationMs, randomAccess) {
            // Make a local copy of indexes
            const indexes = dataMap.map((_, i) => i);

            if (randomAccess) {
                // Shuffle array using a Durstenfeld shuffle
                for (let i = indexes.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indexes[i], indexes[j]] = [indexes[j], indexes[i]];
                }
            }

            let count = 0;
            const start = performance.now();

            while (performance.now() - start < durationMs) {
                const idx = indexes[count % indexes.length];
                const { storeName, key } = dataMap[idx];

                // Single-record GET
                await videoDB.get(storeName, key);
                count++;
            }

            const elapsed = (performance.now() - start) / 1000;
            return Math.round(count / elapsed);
        }

        /**
         * Measures batched GET operations per second for a specified duration.
         * Groups all keys by store, then repeatedly calls `videoDB.getMultiple()` for
         * only some fraction (e.g. 10%) of that store’s rows.
         *
         * @param {Array<{storeName: string, key: string}>} dataMap - The array of stored records.
         * @param {number} durationMs - How long to run the benchmark.
         * @param {number} percentRead - The percentage of rows to read from each store on each pass. (default: 10%)
         * @returns {Promise<number>} Approximate "GETs" per second (i.e., total records retrieved per second).
         */
        async function measureBatchedGetRate(dataMap, durationMs, percentRead) {
            // 1. Group all keys by store
            const storeToKeys = new Map();
            for (const { storeName, key } of dataMap) {
                if (!storeToKeys.has(storeName)) {
                    storeToKeys.set(storeName, []);
                }
                storeToKeys.get(storeName).push(key);
            }

            // For each store, create a dedicated array of keys. We'll read a random subset (percentRead).
            // If a store has 10,000 keys, reading 10% means 1,000 keys per store.
            const allStoreNames = [...storeToKeys.keys()];
            for (const storeName of allStoreNames) {
                const fullArr = storeToKeys.get(storeName);
                // Shuffle once so we can easily pick the top portion each time
                shuffleArray(fullArr);
            }

            let totalRecordsRead = 0;
            const start = performance.now();

            // We'll keep reading until time is up
            while (performance.now() - start < durationMs) {
                for (const storeName of allStoreNames) {
                    const storeKeys = storeToKeys.get(storeName);
                    if (!storeKeys || storeKeys.length === 0) continue;

                    // How many keys to read from this store
                    const readCount = Math.floor((percentRead / 100) * storeKeys.length) || 1;
                    // Grab the first readCount from storeKeys
                    const subset = storeKeys.slice(0, readCount);

                    // Batched get => returns an array of data for these keys
                    await videoDB.getMultiple(storeName, subset);
                    totalRecordsRead += subset.length;
                }
            }

            // Calculate how many records per second
            const elapsed = (performance.now() - start) / 1000;
            return Math.round(totalRecordsRead / elapsed);
        }

        /**
         * Measures **contiguous** batched GET operations per second for a specified duration.
         * Groups all keys by store, then **does NOT shuffle**, so we read keys in their
         * insertion order (i.e., rec_0, rec_1, rec_2, ...).
         *
         * @param {Array<{storeName: string, key: string}>} dataMap - The array of stored records.
         * @param {number} durationMs - How long to run the benchmark.
         * @param {number} percentRead - The percentage of rows to read from each store on each pass.
         * @returns {Promise<number>} Approximate "GETs" per second (i.e. total records read).
         */
        async function measureContiguousBatchedGetRate(dataMap, durationMs, percentRead = 10) {
            // 1. Group all keys by store
            const storeToKeys = new Map();
            for (const { storeName, key } of dataMap) {
                if (!storeToKeys.has(storeName)) {
                    storeToKeys.set(storeName, []);
                }
                storeToKeys.get(storeName).push(key);
            }

            // 2. Sort each store's key list in ascending “rec_0, rec_1, rec_2…” order
            //    so we read from 0 → readCount in contiguous order
            const allStoreNames = [...storeToKeys.keys()];
            for (const storeName of allStoreNames) {
                const arr = storeToKeys.get(storeName);
                arr.sort((a, b) => {
                    // We assume keys look like "rec_123". Parse out the number:
                    const numA = parseInt(a.replace("rec_", ""), 10);
                    const numB = parseInt(b.replace("rec_", ""), 10);
                    return numA - numB;
                });
            }

            let totalRecordsRead = 0;
            const start = performance.now();

            // 3. Keep reading until time is up
            while (performance.now() - start < durationMs) {
                for (const storeName of allStoreNames) {
                    const keysArr = storeToKeys.get(storeName);
                    if (!keysArr || keysArr.length === 0) continue;

                    // e.g., read 10% of that store in ascending order
                    const readCount = Math.floor((percentRead / 100) * keysArr.length) || 1;
                    const subset = keysArr.slice(0, readCount);

                    // Batched GET in “contiguous” ascending order
                    await videoDB.getMultiple(storeName, subset);
                    totalRecordsRead += subset.length;
                }
            }

            const elapsed = (performance.now() - start) / 1000;
            return Math.round(totalRecordsRead / elapsed);
        }

        /**
         * Measures batched GET operations per second for a specified duration.
         * Groups all keys by store, then repeatedly calls `videoDB.getMultiple()` for
         * only some fraction (e.g. 10%) of that store’s rows in a **non-contiguous** fashion.
         * 
         * NOTE: Keys are shuffled upfront (non-contiguous reading).
         *
         * @param {Array<{storeName: string, key: string}>} dataMap - The array of stored records.
         * @param {number} durationMs - How long to run the benchmark.
         * @param {number} percentRead - The percentage of rows to read from each store on each pass. (default: 10%)
         * @returns {Promise<number>} Approximate "GETs" per second (i.e., total records retrieved per second).
         */
        async function measureNonContiguousBatchedGetRate(dataMap, durationMs, percentRead = 10) {
            // 1. Group all keys by store
            const storeToKeys = new Map();
            for (const { storeName, key } of dataMap) {
                if (!storeToKeys.has(storeName)) {
                    storeToKeys.set(storeName, []);
                }
                storeToKeys.get(storeName).push(key);
            }

            // 2. Shuffle each store's key list once, so every subset is "random" in memory
            const allStoreNames = [...storeToKeys.keys()];
            for (const storeName of allStoreNames) {
                const arr = storeToKeys.get(storeName);
                shuffleArray(arr); // <— This is why it’s non-contiguous
            }

            let totalRecordsRead = 0;
            const start = performance.now();

            // 3. Keep reading until time is up
            while (performance.now() - start < durationMs) {
                for (const storeName of allStoreNames) {
                    const keysArr = storeToKeys.get(storeName);
                    if (!keysArr || keysArr.length === 0) continue;

                    // e.g. read 10% of that store
                    const readCount = Math.floor((percentRead / 100) * keysArr.length) || 1;
                    const subset = keysArr.slice(0, readCount);

                    // Batched GET
                    await videoDB.getMultiple(storeName, subset);
                    totalRecordsRead += subset.length;
                }
            }

            const elapsed = (performance.now() - start) / 1000;
            return Math.round(totalRecordsRead / elapsed);
        }

        /** 
         * Simple array shuffle (Durstenfeld/Fisher-Yates)
         */
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        /**
         * Attempts various invalid operations to highlight how the VideoDB class handles errors.
         * Each step is designed to fail and display an [ERROR] in the console.
         */
        async function testErrors() {
            logToConsole("[TASK] Testing error scenarios...");
            logToConsole("");

            // Ensure we have a device/videoDB
            if (!device || !videoDB) {
                await setupDevice();
            }

            // 1. Create a store with a name that already exists
            logToConsole("[STEP] Attempting to create a store with a name that already exists...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Create 'existingStore' twice<br /></b>
videoDB.createObjectStore("existingStore", {<br />
    dataType: "JSON",<br />
    bufferSize: 256,<br />
    totalRows: 1<br />
});<br />
videoDB.createObjectStore("existingStore", {<br />
    dataType: "JSON",<br />
    bufferSize: 256,<br />
    totalRows: 1<br />
});<br />
</code><br />
    `);
            try {
                videoDB.createObjectStore("existingStore", {
                    dataType: "JSON",
                    bufferSize: 256,
                    totalRows: 1
                });
                // Creating it a second time with same name → should throw
                videoDB.createObjectStore("existingStore", {
                    dataType: "JSON",
                    bufferSize: 256,
                    totalRows: 1
                });
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole(""); // blank line between steps

            // 2. Create a TypedArray store without specifying typedArrayType
            logToConsole("[STEP] Attempting to create a TypedArray store with no typedArrayType...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Omit 'typedArrayType' in a TypedArray store<br /></b>
videoDB.createObjectStore("badTypedArrayStore", {<br />
    dataType: "TypedArray",<br />
    bufferSize: 1024,<br />
    totalRows: 10<br />
});<br />
</code><br />
    `);
            try {
                videoDB.createObjectStore("badTypedArrayStore", {
                    dataType: "TypedArray",
                    // typedArrayType missing, should fail
                    bufferSize: 1024,
                    totalRows: 10
                });
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 3. Add a duplicate key to test "add" mode conflict
            logToConsole("[STEP] Adding a duplicate key to a store using 'add' mode...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Duplicate key "testKey" using 'add'<br /></b>
videoDB.createObjectStore("uniqueKeysOnly", {<br />
    dataType: "JSON",<br />
    bufferSize: 1024,<br />
    totalRows: 5<br />
});<br />
await videoDB.add("uniqueKeysOnly", "testKey", { val: 1 });<br />
await videoDB.add("uniqueKeysOnly", "testKey", { val: 2 });<br />
</code><br />
    `);
            try {
                videoDB.createObjectStore("uniqueKeysOnly", {
                    dataType: "JSON",
                    bufferSize: 1024,
                    totalRows: 5
                });
                await videoDB.add("uniqueKeysOnly", "testKey", { val: 1 });
                // Attempt to add again with the same key → should fail
                await videoDB.add("uniqueKeysOnly", "testKey", { val: 2 });
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 4. Put the wrong data type into a TypedArray store
            logToConsole("[STEP] Putting a JSON object in a Float32Array store...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Attempt to store non-float data in a Float32Array store<br /></b>
videoDB.createObjectStore("floatStore", {<br />
    dataType: "TypedArray",<br />
    typedArrayType: "Float32Array",<br />
    bufferSize: 1024,<br />
    totalRows: 5<br />
});<br />
await videoDB.put("floatStore", "wrongData", { not: "a float array" });<br />
</code><br />
    `);
            try {
                videoDB.createObjectStore("floatStore", {
                    dataType: "TypedArray",
                    typedArrayType: "Float32Array",
                    bufferSize: 1024,
                    totalRows: 5
                });
                // Attempting to store a JSON object in a Float32Array store → should fail
                await videoDB.put("floatStore", "wrongData", { not: "a float array" });
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 8. Open cursor on a store that doesn't exist
            logToConsole("[STEP] Opening cursor on 'fakeCursorStore'...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Attempt to open a cursor on non-existing "fakeCursorStore"<br /></b>
for await (const record of videoDB.openCursor("fakeCursorStore")) {<br />
    // ...<br />
}<br />
</code><br />
    `);
            try {
                for await (const record of videoDB.openCursor("fakeCursorStore")) {
                    // Not expected to reach here
                }
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 9. Clear a store that doesn’t exist
            logToConsole("[STEP] Clearing a store that doesn’t exist...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Attempt to clear a non-existing "reallyFakeStore"<br /></b>
videoDB.clear("reallyFakeStore");<br />
</code><br />
    `);
            try {
                videoDB.clear("reallyFakeStore");
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            logToConsole("[INFO] Finished testing error scenarios.");
        }

        /**
         * Stress Test:
         * 1) 5-second countdown.
         * 2) For each store type (JSON, Float32Array, Float64Array, Int32Array, Uint8Array):
         *    - Create the store.
         *    - Run add performance for 5s.
         *    - Run put performance for 5s.
         *    - Run delete performance for 5s.
         *    - Delete the store.
         * 3) Output records/sec for each operation.
         * 4) Display the total size of all data moved from CPU to GPU.
         */
        async function stressTest() {
            // Clear console & code pane
            clearConsole();
            clearCodePane();

            logToConsole("[TASK] Stress Test: Measuring add, put, and delete performance for multiple store types.");

            logToConsole("");
            logToConsole("[NOTE] Each row is approximately 1KB in size.");
            logToConsole("");

            // Show code snippet in the right panel
            logCommandToConsole(`
<code>
<b style='color:green;'>// Stress Test Steps</b><br />
// 1. 5-second countdown in the console.<br />
// 2. For each store type (JSON, Float32, Float64, Int32, Uint8):<br />
//    - Create the store.<br />
//    - Run add performance for 5s.<br />
//    - Run put performance for 5s.<br />
//    - Run delete performance for 5s.<br />
//    - Delete the store.<br />
// 3. Output records/sec for each operation.<br />
// 4. Display total data transferred.<br />
</code>
    `);

            // Make sure we have a GPU device
            if (!device || !videoDB) {
                await setupDevice();
            }

            // 5-second countdown
            await fiveSecondCountdown();

            // Store configs
            const storeConfigs = [
                {
                    name: "jsonStress",
                    options: {
                        dataType: "JSON",
                        bufferSize: 50 * 1024 * 1024,
                        totalRows: 200000
                    }
                },
                {
                    name: "float32Stress",
                    options: {
                        dataType: "TypedArray",
                        typedArrayType: "Float32Array",
                        bufferSize: 50 * 1024 * 1024,
                        totalRows: 200000
                    }
                },
                {
                    name: "float64Stress",
                    options: {
                        dataType: "TypedArray",
                        typedArrayType: "Float64Array",
                        bufferSize: 50 * 1024 * 1024,
                        totalRows: 200000
                    }
                },
                {
                    name: "int32Stress",
                    options: {
                        dataType: "TypedArray",
                        typedArrayType: "Int32Array",
                        bufferSize: 50 * 1024 * 1024,
                        totalRows: 200000
                    }
                },
                {
                    name: "uint8Stress",
                    options: {
                        dataType: "TypedArray",
                        typedArrayType: "Uint8Array",
                        bufferSize: 50 * 1024 * 1024,
                        totalRows: 200000
                    }
                }
            ];

            // Array to collect results
            const perfResults = [];

            // Accumulators for total operations
            let totalAddOps = 0;
            let totalPutOps = 0;
            let totalDelOps = 0;

            // For each store type, run add/put/delete
            for (const cfg of storeConfigs) {
                const { name, options } = cfg;
                logToConsole(`[INFO] Creating store: ${name}`);
                videoDB.createObjectStore(name, options);

                // Prepare ~1KB data
                let dataObj = null;
                if (options.dataType === "JSON") {
                    dataObj = createJsonObject1KB(); // ~1KB JSON
                } else {
                    const floatCount = 1024 / 4; // 256 floats (1KB for float32/64)
                    const typedArrayCtor = globalThis[options.typedArrayType];
                    dataObj = new typedArrayCtor(floatCount);
                    for (let i = 0; i < floatCount; i++) {
                        dataObj[i] = Math.random() * 1000;
                    }
                }

                // 5s add
                const addRate = await runPerfPhase(name, "add", dataObj, 5000);
                const addOps = Math.floor(addRate * 5); // Approximate total adds
                totalAddOps += addOps;

                // 5s put
                const putRate = await runPerfPhase(name, "put", dataObj, 5000);
                const putOps = Math.floor(putRate * 5); // Approximate total puts
                totalPutOps += putOps;

                // 5s delete
                const delRate = await runDeletePhase(name, 5000);
                const delOps = Math.floor(delRate * 5); // Approximate total deletes
                totalDelOps += delOps;

                perfResults.push({ store: name, addRate, putRate, delRate });

                // Delete store
                videoDB.deleteObjectStore(name);

                logToConsole("");
            }

            // Calculate total data transferred (excluding DELETE operations)
            const totalDataKB = (totalAddOps + totalPutOps) * 1; // 1KB per ADD/PUT operation

            let totalDataStr = "";
            if (totalDataKB >= 1024 * 1024) { // 1GB = 1,048,576 KB
                const totalDataGB = (totalDataKB / (1024 * 1024)).toFixed(2);
                totalDataStr = `${totalDataGB} GB`;
            } else {
                const totalDataMB = (totalDataKB / 1024).toFixed(2);
                totalDataStr = `${totalDataMB} MB`;
            }

            // Summarize results
            logToConsole("[RESULTS] Stress Test Performance:");
            for (const r of perfResults) {
                logToConsole(`   ${r.store}: ADD=${r.addRate.toLocaleString()} rec/sec, PUT=${r.putRate.toLocaleString()} rec/sec, DEL=${r.delRate.toLocaleString()} rec/sec`);
            }
            logToConsole(`[RESULTS] Total Data Transferred (ADD/PUT): ${totalDataStr}`);
            logToConsole(``);
            logToConsole("[INFO] Stress Test completed.");
        }

        /**
         * Logs a 5-second countdown in the console.
         */
        function fiveSecondCountdown() {
            return new Promise((resolve) => {
                logToConsole("[STEP] Starting 5-second countdown...");
                let remaining = 5;
                const timer = setInterval(() => {
                    logToConsole(`[INFO] Countdown: ${remaining}s`);
                    remaining--;
                    if (remaining < 0) {
                        clearInterval(timer);
                        resolve();
                        logToConsole(``);
                    }
                }, 1000);
            });
        }

        /**
         * Creates a ~1KB JSON object (simple approach).
         */
        function createJsonObject1KB() {
            const baseObj = { type: "perf", randomVals: [] };
            while (JSON.stringify(baseObj).length < 1024) {
                baseObj.randomVals.push(Math.floor(Math.random() * 1000));
            }
            return baseObj;
        }

        /**
         * Run 'add' or 'put' ops for 'durationMs' with new keys each time.
         * Returns approximate records/second.
         */
        async function runPerfPhase(storeName, operation, dataObj, durationMs) {
            logToConsole(`[STEP] Running '${operation}' phase on store '${storeName}' for ${durationMs / 1000}s...`);
            const startTime = performance.now();
            let count = 0;

            while (performance.now() - startTime < durationMs) {
                const key = `perfKey_${count}`;
                try {
                    if (operation === "add") {
                        await videoDB.add(storeName, key, dataObj);
                    } else {
                        await videoDB.put(storeName, key, dataObj);
                    }
                } catch {
                    // e.g. collision on add -> ignore
                }
                count++;
            }

            const elapsed = (performance.now() - startTime) / 1000;
            const rate = Math.round(count / elapsed);
            logToConsole(`[INFO] Completed ~${count.toLocaleString()} ${operation.toUpperCase()} ops in ${elapsed.toFixed(2)}s => ~${rate.toLocaleString()} rec/sec`);
            return rate;
        }

        /**
         * Run deletes for 'durationMs'
         * Returns approximate records/second.
         */
        async function runDeletePhase(storeName, durationMs) {
            logToConsole(`[STEP] Running 'delete' phase on store '${storeName}' for ${durationMs / 1000}s...`);
            const startTime = performance.now();
            let count = 0;

            while (performance.now() - startTime < durationMs) {
                const key = `perfKey_${count}`;
                await videoDB.delete(storeName, key);
                count++;
            }

            const elapsed = (performance.now() - startTime) / 1000;
            const rate = Math.round(count / elapsed);
            logToConsole(`[INFO] Completed ~${count.toLocaleString()} DELETE ops in ${elapsed.toFixed(2)}s => ~${rate.toLocaleString()} rec/sec`);
            return rate;
        }

        /**
         * Displays the updated VideoDB class documentation in the right pane.
         */
        function showClassDocs() {
            // Optional: clear console and code pane first
            clearConsole();
            clearCodePane();

            // Updated class documentation HTML, reflecting the latest methods and descriptions.
            // Also includes 10px padding-bottom for the bolded labels: Parameters, Returns, Behavior, Example
            const docHtml = `
<h1>VideoDB Class Documentation</h1><br />

<p>
    The <code>VideoDB</code> class provides functionality for managing object stores with
    <strong>CPU-based metadata</strong>. Each object store can represent a collection of key-value
    pairs (or “rows”), fully tracked on the CPU, while the actual row data resides in GPU buffers
    for efficiency. This class implements a deferred-write approach to minimize the overhead of
    frequent GPU operations.
</p><br />

<hr /><br />

<h2>Constructor</h2><br />

<h3><code style="font-size:larger;">constructor(device)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li>
                <code>device</code> (<code>GPUDevice</code>):
                The WebGPU device instance used to allocate GPU buffers.
            </li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        Initializes internal data structures for CPU-based metadata
        (<code>storeMetadataMap</code>) and a map of store keys to row metadata (<code>storeKeyMap</code>).
        Also sets up a mechanism (<code>pendingWrites</code>) for batching GPU write operations.
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>// Suppose you obtained 'device' from navigator.gpu.requestAdapter()
const videoDB = new VideoDB(device);
</code></pre>
    </li>
</ul><br />

<br />

<h2>Methods</h2><br />

<!-- createObjectStore -->
<h3><code style="font-size:larger;">createObjectStore(storeName, options)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li><code>storeName</code> (<code>string</code>): The name for the new store.</li>
            <li>
                <code>options</code> (<code>object</code>):
                <ul>
                    <li><code>dataType</code> (<code>"TypedArray"|"ArrayBuffer"|"JSON"</code>): The data format.</li>
                    <li>
                        <code>typedArrayType</code> (optional):
                        The typed array constructor name (e.g. <code>"Float32Array"</code>, <code>"Float64Array"</code>,
                        <code>"Uint32Array"</code>, <code>"Uint8Array"</code>).
                    </li>
                    <li><code>bufferSize</code> (<code>number</code>): The chunk size for GPU buffers (e.g., 250 MB).</li>
                    <li><code>rowSize</code> (<code>number</code>, optional): The row’s fixed size (if relevant).</li>
                    <li><code>totalRows</code> (<code>number</code>): A hint for total row capacity.</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        <ul>
            <li>Throws an error if the store already exists.</li>
            <li>If <code>dataType</code> is <code>"TypedArray"</code> but <code>typedArrayType</code> is missing, an error is thrown.</li>
            <li>Calculates <code>rowsPerBuffer</code> if <code>dataType</code> is not <code>"JSON"</code> and <code>rowSize</code> is provided.</li>
            <li>Initializes store metadata (e.g., <code>buffers</code>, <code>rows</code>, <code>rowSize</code>, <code>bufferSize</code>).</li>
            <li>Stores the metadata in <code>storeMetadataMap</code> and creates a key map in <code>storeKeyMap</code>.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>videoDB.createObjectStore("myFloatStore", {
    dataType: "TypedArray",
    typedArrayType: "Float32Array",
    bufferSize: 250 * 1024 * 1024,
    totalRows: 1000
});
</code></pre>
    </li>
</ul><br />

<!-- deleteObjectStore -->
<h3><code style="font-size:larger;">deleteObjectStore(storeName)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li><code>storeName</code> (<code>string</code>): The name of the store to delete.</li>
        </ul>
    </li>
    <li><br /><strong style="padding-bottom:5px; display:block;">Returns</strong>
    <code>void</code></li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        <ul>
            <li>If the store doesn’t exist, logs a warning and returns.</li>
            <li>Removes the store’s metadata from <code>storeMetadataMap</code>.</li>
            <li>Removes the store’s key map from <code>storeKeyMap</code>.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>videoDB.deleteObjectStore("myFloatStore");
</code></pre>
    </li>
</ul><br />

<!-- listObjectStores -->
<h3><code style="font-size:larger;">listObjectStores()</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li><br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
    None</li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Returns</strong>
        <code>string[]</code>: The list of all object store names.
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        Returns the keys of <code>storeMetadataMap</code> as an array, indicating all known stores.
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>const stores = videoDB.listObjectStores();
console.log(stores); // e.g. ["myFloatStore", "jsonStore"]
</code></pre>
    </li>
</ul><br />

<!-- add -->
<h3><code style="font-size:larger;">add(storeName, key, value)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li><code>storeName</code> (<code>string</code>): The name of the object store.</li>
            <li><code>key</code> (<code>string</code>): A unique key identifying the row.</li>
            <li><code>value</code> (<code>any</code>): The data (JSON, TypedArray, or ArrayBuffer).</li>
        </ul>
    </li>
    <li><br /><strong style="padding-bottom:5px; display:block;">Returns</strong>
    <code>Promise&lt;void&gt;</code></li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        <ul>
            <li>Throws an error if the store does not exist.</li>
            <li>Throws an error if the key already exists (in “add” mode).</li>
            <li>Serializes the <code>value</code> into an <code>ArrayBuffer</code> and queues a GPU write in <code>pendingWrites</code> without immediate flush.</li>
            <li>Flushes to GPU automatically after 1 second of inactivity or if a batch size threshold is reached.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>// Adding a new JSON record
await videoDB.add("jsonStore", "record1", { foo: "bar", time: Date.now() });
</code></pre>
    </li>
</ul><br />

<!-- put -->
<h3><code style="font-size:larger;">put(storeName, key, value)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li><code>storeName</code> (<code>string</code>): The target store name.</li>
            <li><code>key</code> (<code>string</code>): A unique string identifying the row.</li>
            <li><code>value</code> (<code>any</code>): The data (JSON, TypedArray, or ArrayBuffer).</li>
        </ul>
    </li>
    <li><br /><strong style="padding-bottom:5px; display:block;">Returns</strong>
    <code>Promise&lt;void&gt;</code></li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        <ul>
            <li>If the row doesn’t exist, it’s created; if it does, it’s overwritten (upsert behavior).</li>
            <li>Serializes <code>value</code> into an <code>ArrayBuffer</code> and queues a GPU write in <code>pendingWrites</code>.</li>
            <li>Flushes to GPU automatically after 1 second of inactivity or if a batch size threshold is reached.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>// Inserting a Float32Array into "embeddingStore"
const vector = new Float32Array([1, 2, 3, 4]);
await videoDB.put("embeddingStore", "vector:001", vector);
</code></pre>
    </li>
</ul><br />

<!-- get -->
<h3><code style="font-size:larger;">get(storeName, key)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li><code>storeName</code> (<code>string</code>): The name of the object store.</li>
            <li><code>key</code> (<code>string</code>): The key identifying which row to read. Supports SQL wildcard patterns.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Returns</strong>
        <code>Promise&lt;any|null&gt;</code>: Deserialized data or <code>null</code> if not found.
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">SQL Wildcards</strong>
        <p>This method supports SQL Server–style <code>LIKE</code> patterns in the <code>key</code> parameter. If the key contains
        wildcard characters, it retrieves the first matching key in the store. Otherwise, the key is read as-is.</p>
        <ul>
            <li><code>%</code> matches zero or more characters (<code>.*</code> in regex).</li>
            <li><code>_</code> matches exactly one character (<code>.</code> in regex).</li>
            <li><code>[abc]</code> matches any single character in the set <code>a</code>, <code>b</code>, <code>c</code>.</li>
            <li><code>[^abc]</code> matches any single character <em>not</em> in the set <code>a</code>, <code>b</code>, <code>c</code>.</li>
        </ul>
        <p>Note that these patterns are anchored, so they must match the entire key string from start to finish.</p>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        <ul>
            <li>Ensures all pending writes are flushed before reading (no stale data).</li>
            <li>Uses the <code>getMultiple</code> method internally, allowing the use of wildcard patterns.</li>
            <li>If the <code>key</code> contains wildcards, retrieves the first matching entry; otherwise, retrieves the specified key.</li>
            <li>Returns <code>null</code> if no matching key is found.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>// Retrieving a specific key
const vector = await videoDB.get("embeddingStore", "vector:001");
console.log("Retrieved vector length:", vector.length);

// Using a wildcard pattern to retrieve the first matching key
const firstMatchingVector = await videoDB.get("embeddingStore", "vector:%");
console.log("First matching vector:", firstMatchingVector);
        </code></pre>
    </li>
</ul><br />

<!-- getMultiple -->
<h3><code style="font-size:larger;">getMultiple(storeName, keys)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li><code>storeName</code> (<code>string</code>): The name of the object store.</li>
            <li><code>keys</code> (<code>string[]</code>): The array of keys or wildcard patterns to read.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Returns</strong>
        <code>Promise&lt;(any | null)[]&gt;</code>:
        An array of deserialized data objects, in the same order as the <em>expanded</em> set of keys. If a key (or wildcard expansion) is not found or inactive, the array item is <code>null</code>.
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">SQL Wildcards</strong>
        <p>This method supports SQL Server–style <code>LIKE</code> patterns in the <code>keys</code> parameter. Each pattern is expanded to all matching keys in the store. The list of expanded keys is used for a single bulk read operation.</p>
        <ul>
            <li><code>%</code> matches zero or more characters (<code>.*</code> in regex).</li>
            <li><code>_</code> matches exactly one character (<code>.</code> in regex).</li>
            <li><code>[abc]</code> matches any single character in the set <code>a</code>, <code>b</code>, <code>c</code>.</li>
            <li><code>[^abc]</code> matches any single character <em>not</em> in the set <code>a</code>, <code>b</code>, <code>c</code>.</li>
        </ul>
        <p>These patterns must match the entire key from start to finish. If no actual keys match a wildcard, the corresponding element in the results array is <code>null</code>.</p>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        <ul>
            <li>Flushes any pending writes to avoid stale data.</li>
            <li>Expands all wildcard patterns into concrete keys before a single GPU <code>mapAsync</code> operation.</li>
            <li>Deserializes each row based on <code>storeMeta.dataType</code> and returns them in an array, preserving the expanded key order.</li>
            <li>Any row not found or not active is <code>null</code>.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>// Retrieving multiple specific keys
const items = await videoDB.getMultiple("embeddingStore", ["vector:001", "vector:002"]);
console.log("Results:", items);

// Using wildcard patterns
const wildcardItems = await videoDB.getMultiple("embeddingStore", ["vector:%", "config:%"]);
console.log("Wildcard results:", wildcardItems);
        </code></pre>
    </li>
</ul><br />

<!-- delete -->
<h3><code style="font-size:larger;">delete(storeName, key)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li><code>storeName</code> (<code>string</code>): The name of the object store.</li>
            <li><code>key</code> (<code>string</code>): The key identifying which row to delete.</li>
        </ul>
    </li>
    <li><br /><strong style="padding-bottom:5px; display:block;">Returns</strong>
    <code>Promise&lt;void&gt;</code></li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        <ul>
            <li>If the row is not found or already inactive, logs a message and returns.</li>
            <li>Optionally writes zeros to the GPU buffer for that row (for a “true” data wipe).</li>
            <li>Queues a delete operation in <code>pendingWrites</code>; actual metadata removal happens on flush.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>await videoDB.delete("myFloatStore", "row123");
</code></pre>
    </li>
</ul><br />

<!-- clear -->
<h3><code style="font-size:larger;">clear(storeName)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li><code>storeName</code> (<code>string</code>): The name of the object store to clear.</li>
        </ul>
    </li>
    <li><br /><strong style="padding-bottom:5px; display:block;">Returns</strong>
    <code>void</code></li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        <ul>
            <li>Removes all rows from the store’s metadata array.</li>
            <li>Destroys all GPU buffers associated with the store.</li>
            <li>Recreates a single fresh GPU buffer for subsequent usage.</li>
            <li>Clears the store’s key map and updates metadata.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>videoDB.clear("myFloatStore");
</code></pre>
    </li>
</ul><br />

<!-- openCursor -->
<h3><code style="font-size:larger;">openCursor(storeName, options?)</code></h3><br />
<hr style="margin-top:-10px;">

<ul>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Parameters</strong>
        <ul>
            <li><code>storeName</code> (<code>string</code>): The name of the object store to iterate over.</li>
            <li>
                <code>options</code> (optional, <code>object</code>):
                <ul>
                    <li>
                        <code>range</code> (<code>object</code>):
                        <ul>
                            <li><code>lowerBound</code> (<code>string</code>): The lower bound of keys to include.</li>
                            <li><code>upperBound</code> (<code>string</code>): The upper bound of keys to include.</li>
                            <li><code>lowerInclusive</code> (<code>boolean</code>): Whether the lower bound is inclusive.</li>
                            <li><code>upperInclusive</code> (<code>boolean</code>): Whether the upper bound is inclusive.</li>
                        </ul>
                    </li>
                    <li><code>direction</code> (<code>"next"</code> | <code>"prev"</code>): The direction of iteration.</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Returns</strong>
        <code>AsyncGenerator&lt;{ key: string; value: any }, void, unknown&gt;</code>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Behavior</strong>
        <ul>
            <li>Retrieves store metadata and the key map.</li>
            <li>Collects all active keys from the key map.</li>
            <li>Optionally filters them by the specified <code>range</code>.</li>
            <li>Sorts keys in ascending (<code>"next"</code>) or descending (<code>"prev"</code>) order.</li>
            <li>For each key, retrieves data via <code>get()</code> and yields <code>{ key, value }</code>.</li>
        </ul>
    </li>
    <li>
        <br /><strong style="padding-bottom:5px; display:block;">Example</strong>
        <pre><code>for await (const record of videoDB.openCursor("myFloatStore")) {
    console.log(record.key, record.value);
}

const range = { lowerBound: "100", upperBound: "200", lowerInclusive: true, upperInclusive: false };
for await (const record of videoDB.openCursor("myFloatStore", { range, direction: "prev" })) {
    console.log(record.key, record.value);
}
</code></pre>
    </li>
</ul><br />
</div>
`;

            // Insert into the right pane
            document.getElementById('codePane').innerHTML = docHtml;
        }

        // Initialize the demo page once the DOM is ready
        window.addEventListener('DOMContentLoaded', () => {
            initDemoPage();
        });
    </script>
</body>
</html>
