<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <meta charset="UTF-8" />
    <title>VideoDB Demo</title>
    <style>
        /* Basic reset and font */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: sans-serif;
            background-color: #f6f6f6;
            color: #333;
            padding: 16px;
        }

        /* Container for the three horizontal panels */
        .container {
            display: flex;
            flex-direction: row;
            gap: 16px;
            height: 80vh; /* Adjust as needed */
        }

        /* Left panel (List of tasks) */
        .panel-left {
            flex: 0 0 25%;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            overflow-y: auto;
        }

            .panel-left h2 {
                margin-bottom: 0.5em;
                font-size: 1.2em;
                color: #2c3e50;
            }

        .task-list {
            list-style-type: none;
            padding-left: 0;
        }

            .task-list li {
                margin-bottom: 16px;
            }

            .task-list a {
                color: #0066cc;
                text-decoration: none;
                font-weight: bold;
                cursor: pointer;
            }

        .task-description {
            display: block;
            margin-top: 4px;
            font-size: 0.85em;
            color: #555;
        }

        /* Middle panel (Console) */
        .panel-middle {
            flex: 0 0 35%;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            overflow-y: auto;
        }

            .panel-middle h2 {
                margin-bottom: 0.5em;
                font-size: 1.2em;
                color: #2c3e50;
            }

        .console-log {
            background: #fafafa;
            border: 1px solid #ddd;
            min-height: 60vh;
            padding: 8px;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 0.9em;
        }

        /* Right panel (Code Snippets) */
        .panel-right {
            flex: 1;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            overflow-y: auto;
        }

            .panel-right h2 {
                margin-bottom: 0.5em;
                font-size: 1.2em;
                color: #2c3e50;
            }

        .code-pane {
            border: 1px solid #ddd;
            background: #fefefe;
            min-height: 60vh;
            border-radius: 4px;
            padding: 8px;
            font-family: monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h3>VideoDB Demo Page</h3>
    <br />
    <p>
        The <code>VideoDB</code> class is a GPU-backed alternative to <code>IndexedDB</code>, designed for high-performance data storage and retrieval. It leverages <code>WebGPU</code> to manage data in GPU memory, allowing for faster access and computation compared to traditional browser storage solutions.
        The class supports various data types, including JSON objects and typed arrays (e.g., Float32Array, Float64Array, Int32Array, Uint32Array, Uint8Array), making it suitable for applications requiring efficient handling of structured or binary data.
    </p>
    <br />
    <p>
        <code>VideoDB</code> is particularly advantageous for applications such as real-time data processing, machine learning, and complex visualizations where performance and scalability are critical. It blends the familiarity of web-based storage paradigms with the power of GPU acceleration.
    </p>
    <br />
    <p>
        Select a link in the first panel to view console logs (middle panel) and the corresponding code snippets (right panel).
    </p>
    <br />

    <div class="container">
        <!-- Left Panel: List of tasks/links -->
        <div class="panel-left">
            <h2>VideoDB Tasks</h2>
            <ul class="task-list">
                <!-- Keep GPU check -->
                <li>
                    <a href="#" data-task="checkGPU">Check GPU Availability</a>
                    <span class="task-description">Quickly verify if WebGPU is supported in the user’s browser.</span>
                </li>

                <!-- Single, combined test for all store types -->
                <li>
                    <a href="#" data-task="manageAllStores">Create and Manage All Store Types</a>
                    <span class="task-description">Create, put data, get data, delete data, then delete the store for JSON, Float32, Float64, Int32, Uint32, Uint8.</span>
                </li>

                <!-- Insert this block below the existing "Create and Manage All Store Types" list item -->
                <li>
                    <a href="#" data-task="testErrors">Force a Bunch of Errors</a>
                    <span class="task-description">Deliberately attempt invalid operations to showcase error handling.</span>
                </li>

                <li>
                    <a href="#" data-task="classDocs">Class Documentation</a>
                    <span class="task-description">View the complete VideoDB class docs in the right pane.</span>
                </li>
            </ul>
        </div>

        <!-- Middle Panel: Console Output -->
        <div class="panel-middle">
            <h2>Console View</h2>
            <div class="console-log" id="consoleLog">
                <!-- Textual messages from tasks appear here. -->
            </div>
        </div>

        <!-- Right Panel: Code Snippets -->
        <div class="panel-right">
            <h2>Code Snippets</h2>
            <div id="codePane">
                <!-- Code or commands for the chosen task will appear here. -->
                <p>No code to show. Select a task from the left panel.</p>
            </div>
        </div>
    </div>

    <!-- Updated script block -->
    <script type="module">
        import { VideoDB } from './js/VideoDB.js';

        /**
         * Logs a message to the consoleLog div (middle panel).
         * - Converts `[SUCCESS]` to green text.
         * - Converts `[ERROR]` to red text.
         * - Inserts line breaks for newlines.
         * @param {string} msg - The message to display in the console area.
         * @returns {void}
         */
        function logToConsole(msg) {
            const consoleDiv = document.getElementById('consoleLog');

            // Replace [SUCCESS] / [ERROR] / [TASK] tags with colored <b> elements
            // Also convert any "\n" (newlines) into <br/> for line breaks in HTML
            let styledMsg = msg
                .replace(/\[SUCCESS\]/g, "<b style='color: green;'>[SUCCESS]</b>")
                .replace(/\[ERROR\]/g, "<b style='color: red;'>[ERROR]</b>")
                .replace(/\[TASK\]/g, "<b style='color: navy;'>[TASK]</b>")
                .replace(/\n/g, "<br/>");

            // Append the formatted message (plus a new line) to the existing HTML
            consoleDiv.innerHTML += styledMsg + "<br/>";
        }

        /**
         * Logs an HTML-based command to the codePane div (right panel), with formatting.
         * @param {string} htmlCommand - The HTML content to display in the code area as a command.
         * @returns {void}
         */
        function logCommandToConsole(htmlCommand) {
            const codeDiv = document.getElementById('codePane');
            // Append to existing content, preserving any existing code
            codeDiv.innerHTML += `<div style="margin-left: 10px;"><strong>${htmlCommand}</strong></div>`;
        }

        /**
         * Clears the console window (middle panel).
         * @returns {void}
         */
        function clearConsole() {
            const consoleDiv = document.getElementById('consoleLog');
            consoleDiv.textContent = '';
        }

        /**
         * Clears the code pane (right panel).
         * @returns {void}
         */
        function clearCodePane() {
            const codeDiv = document.getElementById('codePane');
            codeDiv.innerHTML = '<p></p>';
        }

        // We'll keep a reference to our VideoDB instance and device
        let videoDB = null;
        let device = null;

        /**
         * Initializes the page by attaching event listeners for each task link.
         * @returns {Promise<void>}
         */
        async function initDemoPage() {
            // Attach event listeners for each link with a data-task attribute
            const taskLinks = document.querySelectorAll('.task-list a[data-task]');
            taskLinks.forEach(link => {
                link.addEventListener('click', async (event) => {
                    event.preventDefault();
                    const task = link.getAttribute('data-task');

                    // Clear both console and code pane before each new task
                    clearConsole();
                    clearCodePane();

                    switch (task) {
                        case 'checkGPU':
                            await checkGPU();
                            break;
                        case 'manageAllStores':
                            await manageAllStores();
                            break;
                        case 'testErrors':
                            await testErrors();
                            break;
                        case 'classDocs':
                            showClassDocs();
                            break;
                        default:
                            logToConsole(`[ERROR] Unknown task: ${task}`);
                            break;
                    }
                });
            });

            // Optional: Immediately try to request the GPU device
            await setupDevice();
        }

        /**
         * Sets up the GPU device and creates a VideoDB instance for use in demos.
         * @returns {Promise<void>}
         */
        async function setupDevice() {
            if (!('gpu' in navigator)) {
                logToConsole("[INFO] WebGPU is not supported in this environment.");
                logToConsole("If using Chrome or Edge, try enabling WebGPU in chrome://flags or edge://flags.");
                return;
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                logToConsole("[ERROR] Failed to get GPU adapter.");
                logToConsole("Check if experimental features are enabled (chrome://flags or edge://flags).");
                return;
            }
            device = await adapter.requestDevice();
            videoDB = new VideoDB(device);

            // Just to confirm that we have the device
            logToConsole("[INFO] Successfully created VideoDB instance.");
        }

        /**
         * Quickly verify if WebGPU is supported in the user’s browser.
         * @returns {Promise<void>}
         */
        async function checkGPU() {
            logToConsole("[TASK] Checking GPU availability...");

            // STEP 1: Attempt to create or confirm the GPU device
            logToConsole("[Step 1] Attempting to request the GPU device...");
            if (!device) {
                await setupDevice();
            }

            // STEP 2: Success or fail message
            if (device) {
                logToConsole("[SUCCESS] GPU device is available. WebGPU is supported.");
                logToConsole("If you had issues, ensure your Chrome/Edge flags are set to enable WebGPU.");
            } else {
                logToConsole("[FAIL] WebGPU not supported or device not available.");
                logToConsole("Enable WebGPU via chrome://flags or edge://flags, then relaunch.");
            }

            // Show code snippet in the right pane
            logCommandToConsole(`
<code>
<b style='color:green;'>// 1. Attempt to request the GPU device</b><br />
const adapter = await navigator.gpu.requestAdapter();<br />
if (!adapter) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;logToConsole("[ERROR] Failed to get GPU adapter.");<br />
&nbsp;&nbsp;&nbsp;&nbsp;return;<br />
}<br /><br />

<b style='color:green;'>// 2. Create the device and instantiate VideoDB</b><br />
device = await adapter.requestDevice();<br />
videoDB = new VideoDB(device);<br /><br />
</code>
                `);
        }

        /**
         * A helper to perform the same 5-step “create, put, get, delete data, delete store” process
         * for any store configuration (JSON or typed arrays).
         * @param {string} storeName
         * @param {object} storeOptions - Options for createObjectStore
         * @param {*} dataToInsert - Data to insert (JSON object or TypedArray)
         * @param {string} key - The key under which data will be put
         */
        async function manageSingleStore(storeName, storeOptions, dataToInsert, key) {
            logToConsole(`[TASK] Managing store '${storeName}'...`);

            // 1. Create the store
            logToConsole(`[Step 1] Creating store '${storeName}'...`);
            videoDB.createObjectStore(storeName, storeOptions);
            logToConsole(`[SUCCESS] Created '${storeName}'.`);

            logCommandToConsole(`
<code>
<b style='color:green;'>// 1. Create the store: ${storeName}</b><br />
videoDB.createObjectStore("${storeName}", ${JSON.stringify(storeOptions, null, 4)});<br /><br />
</code>
            `);

            // 2. Put data
            // Build a snippet that accurately reflects typed arrays vs. JSON
            let snippetForDataToInsert;
            if (storeOptions.dataType === "TypedArray") {
                // Example: new Float32Array([1.11, 2.22, 3.33])
                const arrayData = Array.from(dataToInsert);
                snippetForDataToInsert = `new ${storeOptions.typedArrayType}(${JSON.stringify(arrayData)})`;
            } else {
                // JSON or other data gets normal JSON.stringify
                snippetForDataToInsert = JSON.stringify(dataToInsert, null, 4);
            }

            logToConsole(`[Step 2] Putting data into '${storeName}' under key '${key}': ${dataToInsert}`);
            await videoDB.put(storeName, key, dataToInsert);
            logToConsole(`[SUCCESS] Data inserted under key '${key}'.`);

            logCommandToConsole(`
<code>
<b style='color:green;'>// 2. Put data</b><br />
const sampleData = ${snippetForDataToInsert};<br />
await videoDB.put("${storeName}", "${key}", sampleData);<br /><br />
</code>
            `);

            // 3. Get data
            logToConsole(`[Step 3] Retrieving data from '${storeName}' key '${key}'...`);
            const retrieved = await videoDB.get(storeName, key);

            // Convert typed array to string if necessary
            let retrievedStr = retrieved;
            if (retrieved && typeof retrieved.join === "function") {
                retrievedStr = retrieved.join(", ");
            } else if (typeof retrieved === 'object') {
                retrievedStr = JSON.stringify(retrieved);
            }
            logToConsole(`[SUCCESS] Retrieved data: ${retrievedStr}`);

            logCommandToConsole(`
<code>
<b style='color:green;'>// 3. Get data</b><br />
const retrieved = await videoDB.get("${storeName}", "${key}");<br />
console.log("Retrieved:", retrieved);<br /><br />
</code>
            `);

            // 4. Delete data (simulate by overwriting with empty object or empty typed array)
            logToConsole("[Step 4] Deleting data (overwriting)...");
            let emptyValue = {};
            if (storeOptions.dataType === "TypedArray") {
                // Create an empty typed array of the same type
                emptyValue = new self[storeOptions.typedArrayType](0);
            }
            await videoDB.put(storeName, key, emptyValue);
            logToConsole(`[SUCCESS] Overwrote '${key}' with an empty ${storeOptions.typedArrayType || "object"}.`);

            const snippetForEmptyValue = storeOptions.dataType === "TypedArray"
                ? `new ${storeOptions.typedArrayType}([])`
                : `{}`;

            logCommandToConsole(`
<code>
<b style='color:green;'>// 4. Delete data (by overwriting)</b><br />
await videoDB.put("${storeName}", "${key}", ${snippetForEmptyValue});<br /><br />
</code>
            `);

            // 5. Delete the store
            logToConsole(`[Step 5] Deleting store '${storeName}'...`);
            videoDB.deleteObjectStore(storeName);
            logToConsole(`[SUCCESS] '${storeName}' deleted.`);

            logCommandToConsole(`
<code>
<b style='color:green;'>// 5. Delete the store</b><br />
videoDB.deleteObjectStore("${storeName}");<br /><br />
</code>
            `);

            // Add a blank line for spacing in the console
            logToConsole("");
        }

        /**
         * Combined multi-step test: creates and manages
         * (1) JSON store, (2) Float32Array, (3) Float64Array,
         * (4) Int32Array, (5) Uint32Array, (6) Uint8Array.
         */
        async function manageAllStores() {
            // Ensure we have a device/videoDB
            if (!device || !videoDB) {
                await setupDevice();
            }

            try {
                // 1) JSON store
                await manageSingleStore(
                    "jsonStore",
                    {
                        dataType: "JSON",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    { greeting: "Hello JSON Store!", time: Date.now() },
                    "myJsonKey"
                );

                // 2) Float32Array
                await manageSingleStore(
                    "float32Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Float32Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Float32Array([1.11, 2.22, 3.33]),
                    "myFloat32Key"
                );

                // 3) Float64Array
                await manageSingleStore(
                    "float64Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Float64Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Float64Array([10.01, 20.02, 30.03]),
                    "myFloat64Key"
                );

                // 4) Int32Array
                await manageSingleStore(
                    "int32Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Int32Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Int32Array([-1, 0, 99999]),
                    "myInt32Key"
                );

                // 5) Uint32Array
                await manageSingleStore(
                    "uint32Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Uint32Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Uint32Array([123456, 987654321, 42]),
                    "myUint32Key"
                );

                // 6) Uint8Array
                await manageSingleStore(
                    "uint8Store",
                    {
                        dataType: "TypedArray",
                        typedArrayType: "Uint8Array",
                        bufferSize: 1024 * 1024,
                        totalRows: 50
                    },
                    new Uint8Array([0, 255, 128, 64]),
                    "myUint8Key"
                );

                logToConsole("[SUCCESS] All store types created, managed, and deleted in one go!");
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
        }

        /**
         * Attempts various invalid operations to highlight how the VideoDB class handles errors.
         * Each step is designed to fail and display an [ERROR] in the console.
         */
        async function testErrors() {
            logToConsole("[TASK] Testing error scenarios...");

            // Ensure we have a device/videoDB
            if (!device || !videoDB) {
                await setupDevice();
            }

            // 1. Create a store with a name that already exists
            logToConsole("[Step 1] Attempting to create a store with a name that already exists...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Step 1: Create 'existingStore' twice<br /></b>
videoDB.createObjectStore("existingStore", {<br />
    dataType: "JSON",<br />
    bufferSize: 256,<br />
    totalRows: 1<br />
});<br />
videoDB.createObjectStore("existingStore", {<br />
    dataType: "JSON",<br />
    bufferSize: 256,<br />
    totalRows: 1<br />
});<br />
</code><br />
    `);
            try {
                videoDB.createObjectStore("existingStore", {
                    dataType: "JSON",
                    bufferSize: 256,
                    totalRows: 1
                });
                // Creating it a second time with same name → should throw
                videoDB.createObjectStore("existingStore", {
                    dataType: "JSON",
                    bufferSize: 256,
                    totalRows: 1
                });
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole(""); // blank line between steps

            // 2. Create a TypedArray store without specifying typedArrayType
            logToConsole("[Step 2] Attempting to create a TypedArray store with no typedArrayType...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Step 2: Omit 'typedArrayType' in a TypedArray store<br /></b>
videoDB.createObjectStore("badTypedArrayStore", {<br />
    dataType: "TypedArray",<br />
    bufferSize: 1024,<br />
    totalRows: 10<br />
});<br />
</code><br />
    `);
            try {
                videoDB.createObjectStore("badTypedArrayStore", {
                    dataType: "TypedArray",
                    // typedArrayType missing, should fail
                    bufferSize: 1024,
                    totalRows: 10
                });
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 3. Add a duplicate key to test "add" mode conflict
            logToConsole("[Step 3] Adding a duplicate key to a store using 'add' mode...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Step 3: Duplicate key "testKey" using 'add'<br /></b>
videoDB.createObjectStore("uniqueKeysOnly", {<br />
    dataType: "JSON",<br />
    bufferSize: 1024,<br />
    totalRows: 5<br />
});<br />
await videoDB.add("uniqueKeysOnly", "testKey", { val: 1 });<br />
await videoDB.add("uniqueKeysOnly", "testKey", { val: 2 });<br />
</code><br />
    `);
            try {
                videoDB.createObjectStore("uniqueKeysOnly", {
                    dataType: "JSON",
                    bufferSize: 1024,
                    totalRows: 5
                });
                await videoDB.add("uniqueKeysOnly", "testKey", { val: 1 });
                // Attempt to add again with the same key → should fail
                await videoDB.add("uniqueKeysOnly", "testKey", { val: 2 });
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 4. Put the wrong data type into a TypedArray store
            logToConsole("[Step 4] Putting a JSON object in a Float32Array store...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Step 4: Attempt to store non-float data in a Float32Array store<br /></b>
videoDB.createObjectStore("floatStore", {<br />
    dataType: "TypedArray",<br />
    typedArrayType: "Float32Array",<br />
    bufferSize: 1024,<br />
    totalRows: 5<br />
});<br />
await videoDB.put("floatStore", "wrongData", { not: "a float array" });<br />
</code><br />
    `);
            try {
                videoDB.createObjectStore("floatStore", {
                    dataType: "TypedArray",
                    typedArrayType: "Float32Array",
                    bufferSize: 1024,
                    totalRows: 5
                });
                // Attempting to store a JSON object in a Float32Array store → should fail
                await videoDB.put("floatStore", "wrongData", { not: "a float array" });
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 5. Get a key that does not exist
            logToConsole("[Step 5] Attempting to get a non-existing key from 'floatStore'...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Step 5: Get a key that doesn't exist in 'floatStore'<br /></b>
const missingData = await videoDB.get("floatStore", "doesNotExist");<br />
</code><br />
    `);
            try {
                const missingData = await videoDB.get("floatStore", "doesNotExist");
                if (missingData === null) {
                    logToConsole("[SUCCESS] Key not found, returned null as expected.");
                } else {
                    logToConsole("[ERROR] Unexpected result, expected null!");
                }
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 6. Delete a key that does not exist
            logToConsole("[Step 6] Deleting a non-existing key from 'floatStore'...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Step 6: Delete a key that doesn't exist<br /></b>
await videoDB.delete("floatStore", "randomKey");<br />
</code><br />
    `);
            try {
                await videoDB.delete("floatStore", "randomKey");
                // This shouldn't throw an Error, but logs a warning
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 7. Delete a store that doesn't exist
            logToConsole("[Step 7] Deleting a non-existing store...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Step 7: Delete "fakeStoreName" which doesn't exist<br /></b>
videoDB.deleteObjectStore("fakeStoreName");<br />
</code><br />
    `);
            try {
                videoDB.deleteObjectStore("fakeStoreName");
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 8. Open cursor on a store that doesn't exist
            logToConsole("[Step 8] Opening cursor on 'fakeCursorStore'...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Step 8: Attempt to open a cursor on non-existing "fakeCursorStore"<br /></b>
for await (const record of videoDB.openCursor("fakeCursorStore")) {<br />
    // ...<br />
}<br />
</code><br />
    `);
            try {
                for await (const record of videoDB.openCursor("fakeCursorStore")) {
                    // Not expected to reach here
                }
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            // 9. Clear a store that doesn’t exist
            logToConsole("[Step 9] Clearing a store that doesn’t exist...");
            logCommandToConsole(`
<code>
<b style="color:green;">// Step 9: Attempt to clear a non-existing "reallyFakeStore"<br /></b>
videoDB.clear("reallyFakeStore");<br />
</code><br />
    `);
            try {
                videoDB.clear("reallyFakeStore");
            } catch (err) {
                logToConsole("[ERROR] " + err.message);
            }
            logToConsole("");

            logToConsole("[INFO] Finished testing error scenarios.");
        }

        /**
         * Displays the VideoDB class documentation in the right pane.
         */
        function showClassDocs() {
            // Optional: clear console and code pane first
            clearConsole();
            clearCodePane();

            // Below is the main class documentation HTML; note the added <br /><br /> tags
            const docHtml = `
<h1>VideoDB Class Documentation</h1><br /><br />

<p>
              The <code>VideoDB</code> class provides functionality for managing object stores with
              <strong>CPU-based metadata</strong>. Each object store can represent a collection of key-value
              pairs (or “rows”), fully tracked on the CPU, while the actual row data resides in GPU buffers
              for efficiency...
</p><br /><br />

<hr /><br /><br />

<h2>Constructor</h2><br /><br />

<h3><code>constructor(device)</code></h3><br /><br />

<ul>
              <li>
                <strong>Parameters</strong>
                <ul>
                  <li>
                    <code>device</code> (<code>GPUDevice</code>): The WebGPU device instance used
                    to allocate GPU buffers.
                  </li>
                </ul>
              </li>
              <li>
                <strong>Behavior</strong><br>
                Initializes internal data structures for CPU-based metadata (<code>storeMetadataMap</code>)
                and a map of store <em>keys</em> to row IDs (<code>storeKeyMap</code>).
              </li>
              <li>
                <strong>Example</strong>
                <pre><code>// Suppose you obtained device from navigator.gpu.requestAdapter()
const videoDB = new VideoDB(device);
</code></pre>
              </li>
</ul><br /><br />

<hr /><br /><br />

<h2>Methods</h2><br /><br />

<h3><code>createObjectStore(storeName, options)</code></h3><br /><br />

<ul>
              <li>
                <strong>Parameters</strong>
                <ul>
                  <li><code>storeName</code> (<code>string</code>): The name for the new store.</li>
                  <li>
                    <code>options</code> (<code>object</code>):
                    <ul>
                      <li><code>dataType</code> (<code>"TypedArray"|"ArrayBuffer"|"JSON"</code>): The data format.</li>
                      <li>
                        <code>typedArrayType</code> (optional):
                        The typed array constructor name (e.g. <code>"Float32Array"</code>, <code>"Float64Array"</code>,
                        <code>"Uint32Array"</code>, <code>"Uint8Array"</code>).
                      </li>
                      <li><code>bufferSize</code> (<code>number</code>): The chunk size for GPU buffers (e.g., 250 MB).</li>
                      <li><code>rowSize</code> (<code>number</code>, optional): The row’s fixed size (if relevant).</li>
                      <li><code>totalRows</code> (<code>number</code>): A hint for total row capacity.</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <strong>Behavior</strong><br>
                Creates internal metadata for the store and adds it to <code>storeMetadataMap</code>, also
                sets up a <code>Map&lt;string, number&gt;</code> for <code>key → rowId</code> references.
              </li>
              <li>
                <strong>Example</strong>
                <pre><code>videoDB.createObjectStore("myFloatStore", {
              dataType: "TypedArray",
              typedArrayType: "Float32Array",
              bufferSize: 250 * 1024 * 1024,
              totalRows: 1000
});
</code></pre>
              </li>
</ul><br /><br />

<h3><code>listObjectStores()</code></h3><br /><br />

<ul>
              <li><strong>Parameters</strong><br>None</li>
              <li><strong>Returns</strong><br><code>string[]</code>: The list of all object store names.</li>
              <li>
                <strong>Behavior</strong><br>
                Returns the keys of <code>storeMetadataMap</code> as an array, indicating all known stores.
              </li>
              <li>
                <strong>Example</strong>
                <pre><code>const stores = videoDB.listObjectStores();
console.log(stores); // e.g. ["myFloatStore", "jsonStore"]
</code></pre>
              </li>
</ul><br /><br />

<h3><code>deleteObjectStore(storeName)</code></h3><br /><br />

<ul>
              <li>
                <strong>Parameters</strong>
                <ul>
                  <li><code>storeName</code> (<code>string</code>): The name of the store to delete.</li>
                </ul>
              </li>
              <li><strong>Returns</strong><br><code>void</code></li>
              <li>
                <strong>Behavior</strong><br>
                <ul>
                  <li>Removes the store’s metadata from <code>storeMetadataMap</code>.</li>
                  <li>Deletes the store’s key map from <code>storeKeyMap</code>.</li>
                  <li>Iterates over all allocated GPU buffers for that store and calls <code>.destroy()</code> on each.</li>
                  <li>Logs a message indicating the store is deleted.</li>
                </ul>
              </li>
              <li>
                <strong>Example</strong>
                <pre><code>videoDB.deleteObjectStore("myFloatStore");
</code></pre>
              </li>
</ul><br /><br />

<h3><code>put(storeName, key, value)</code></h3><br /><br />

<ul>
              <li>
                <strong>Parameters</strong>
                <ul>
                  <li><code>storeName</code> (<code>string</code>): The target store name.</li>
                  <li><code>key</code> (<code>string</code>): A unique string identifying the row.</li>
                  <li><code>value</code> (<code>any</code>): The data. Must match the store’s <code>typedArrayType</code> if typed.</li>
                </ul>
              </li>
              <li><strong>Returns</strong><br><code>Promise&lt;void&gt;</code></li>
              <li>
                <strong>Behavior</strong>
                <ol>
                  <li>
                    If no existing row, allocate space in the last buffer chunk (e.g., 250 MB). If it won’t fit,
                    create a new chunk. Write data at that offset and store row metadata (<code>rowId</code>, <code>offset</code>, etc.).
                  </li>
                  <li>
                    If the row already exists and the new data is bigger, mark the old row as inactive, allocate
                    a new row, and write the updated data there.
                  </li>
                  <li>Marks store metadata as dirty (<code>dirtyMetadata = true</code>) and increments <code>metadataVersion</code>.</li>
                </ol>
              </li>
              <li>
                <strong>Example</strong>
                <pre><code>// Inserting a Float32Array into "embeddingStore"
const vector = new Float32Array([1, 2, 3, 4]);
await videoDB.put("embeddingStore", "vector:001", vector);
</code></pre>
              </li>
</ul><br /><br />

<h3><code>get(storeName, key)</code></h3><br /><br />

<ul>
              <li>
                <strong>Parameters</strong>
                <ul>
                  <li><code>storeName</code> (<code>string</code>): The name of the object store.</li>
                  <li><code>key</code> (<code>string</code>): The key identifying which row to read.</li>
                </ul>
              </li>
              <li>
                <strong>Returns</strong><br><code>Promise&lt;any|null&gt;</code>: Deserialized data or <code>null</code> if inactive.
              </li>
              <li>
                <strong>Behavior</strong>
                <ol>
                  <li>Looks up <code>rowId</code> from the store’s key map. If none, returns <code>null</code>.</li>
                  <li>If flagged inactive, returns <code>null</code>.</li>
                  <li>Maps the chunk buffer (<code>GPUMapMode.READ</code>) at the row’s <code>offset</code>.</li>
                  <li>Copies data into CPU memory, then unmaps the buffer.</li>
                  <li>Deserializes (JSON, TypedArray, or ArrayBuffer).</li>
                  <li>Returns the result.</li>
                </ol>
              </li>
              <li>
                <strong>Example</strong>
                <pre><code>const vector = await videoDB.get("embeddingStore", "vector:001");
console.log("Retrieved vector length:", vector.length);
</code></pre>
              </li>
</ul><br /><br />

<!-- NEW METHODS BELOW -->

<h3><code>delete(storeName, key)</code></h3><br /><br />

<ul>
              <li>
                <strong>Parameters</strong>
                <ul>
                  <li><code>storeName</code> (<code>string</code>): The name of the object store.</li>
                  <li><code>key</code> (<code>string</code>): The key identifying which row to delete.</li>
                </ul>
              </li>
              <li><strong>Returns</strong><br><code>Promise&lt;void&gt;</code></li>
              <li>
                <strong>Behavior</strong>
                <ol>
                  <li>Retrieves store metadata and the key map.</li>
                  <li>Finds the active row metadata corresponding to <code>key</code>. If not found or already inactive, logs a warning and returns.</li>
                  <li>Optionally wipes the associated GPU data by setting it to zero or another method to ensure “true” deletion.</li>
                  <li>Marks the row as inactive and removes the <code>key</code> from the key map.</li>
                  <li>Updates store metadata to reflect the deletion.</li>
                </ol>
              </li>
              <li>
                <strong>Example</strong>
                <pre><code>await videoDB.delete("myFloatStore", "row123");
</code></pre>
              </li>
</ul><br /><br />

<h3><code>clear(storeName)</code></h3><br /><br />

<ul>
              <li>
                <strong>Parameters</strong>
                <ul>
                  <li><code>storeName</code> (<code>string</code>): The name of the object store to clear.</li>
                </ul>
              </li>
              <li><strong>Returns</strong><br><code>void</code></li>
              <li>
                <strong>Behavior</strong>
                <ol>
                  <li>Retrieves store metadata and the key map for the specified store.</li>
                  <li>Discards all row metadata by setting <code>storeMeta.rows</code> to an empty array.</li>
                  <li>Destroys all existing GPU buffers associated with the store.</li>
                  <li>Clears the array of buffers and creates one fresh buffer for the store.</li>
                  <li>Clears the key map so there are no active keys.</li>
                  <li>Updates store metadata and increments its version.</li>
                </ol>
              </li>
              <li>
                <strong>Example</strong>
                <pre><code>videoDB.clear("myFloatStore");
</code></pre>
              </li>
</ul><br /><br />

<h3><code>openCursor(storeName, options?)</code></h3><br /><br />

<ul>
              <li>
                <strong>Parameters</strong>
                <ul>
                  <li><code>storeName</code> (<code>string</code>): The name of the object store to iterate over.</li>
                  <li>
                    <code>options</code> (optional, <code>object</code>):
                    <ul>
                      <li>
                        <code>range</code> (<code>object</code>):
                        <ul>
                          <li><code>lowerBound</code> (<code>string</code>): The lower bound of keys to include.</li>
                          <li><code>upperBound</code> (<code>string</code>): The upper bound of keys to include.</li>
                          <li><code>lowerInclusive</code> (<code>boolean</code>): Whether the lower bound is inclusive.</li>
                          <li><code>upperInclusive</code> (<code>boolean</code>): Whether the upper bound is inclusive.</li>
                        </ul>
                      </li>
                      <li><code>direction</code> (<code>"next"</code> | <code>"prev"</code>): The direction of iteration.</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><strong>Returns</strong><br><code>AsyncGenerator&lt;{ key: string; value: any }, void, unknown&gt;</code></li>
              <li>
                <strong>Behavior</strong>
                <ol>
                  <li>Retrieves store metadata and the key map.</li>
                  <li>Collects all active keys from the key map.</li>
                  <li>Applies optional <code>range</code> filtering, removing keys that fall outside the specified bounds.</li>
                  <li>Sorts keys according to the specified <code>direction</code> (<code>"next"</code> ascending, <code>"prev"</code> descending).</li>
                  <li>Iterates over each key, retrieves the record via <code>get()</code>, and yields <code>{ key, value }</code>.</li>
                </ol>
              </li>
              <li>
                <strong>Example</strong>
                <pre><code>for await (const record of videoDB.openCursor("myFloatStore")) {
              console.log(record.key, record.value);
}

const range = { lowerBound: "100", upperBound: "200", lowerInclusive: true, upperInclusive: false };
for await (const record of videoDB.openCursor("myFloatStore", { range, direction: "prev" })) {
              console.log(record.key, record.value);
}
</code></pre>
              </li>
</ul><br /><br />

<hr /><br /><br />

<div style="font-family: Consolas, 'Courier New', monospace; color: #333; background-color: #f5f5f5; border: 1px solid #ccc; padding: 20px; margin: 10px 0; border-radius: 4px;">
              <h2 style="margin-top: 0;">Usage Example</h2><br /><br />
              <pre style="margin: 0;">
<code style="white-space: pre;">
// 1. Obtain a GPUDevice (e.g., after requestAdapter()/requestDevice())
const device = await navigator.gpu.requestAdapter()
              .then(adapter => adapter.requestDevice());

// 2. Instantiate the VideoDB class
const videoDB = new VideoDB(device);

// 3. Create an object store for Float32 typed arrays
videoDB.createObjectStore("embeddingStore", {
                dataType: "TypedArray",
                typedArrayType: "Float32Array",
                bufferSize: 250 * 1024 * 1024, // 250MB
                totalRows: 1000
});

// 4. Put data
const embed = new Float32Array([1.23, 4.56, 7.89]);
await videoDB.put("embeddingStore", "embed1", embed);

// 5. Retrieve data
const result = await videoDB.get("embeddingStore", "embed1");
console.log("Retrieved typed array:", result);

// 6. Create a JSON-based store
videoDB.createObjectStore("myJsonStore", {
                dataType: "JSON",
                bufferSize: 250 * 1024 * 1024,
                totalRows: 100
});

const demoObject = {
                userId: 12345,
                name: "John Doe",
                preferences: { theme: "dark", notifications: true },
                timestamp: new Date().toISOString()
};
await videoDB.put("myJsonStore", "user:12345", demoObject);

// 7. Read the JSON back
const doc = await videoDB.get("myJsonStore", "user:12345");
console.log("Retrieved JSON doc:", doc);

// 8. Delete the store
videoDB.deleteObjectStore("myJsonStore");
</code>
              </pre><br /><br />
</div>
`;

            // Insert into the right pane
            document.getElementById('codePane').innerHTML = docHtml;
        }

        // Initialize the demo page once the DOM is ready
        window.addEventListener('DOMContentLoaded', () => {
            initDemoPage();
        });
    </script>
</body>
</html>
